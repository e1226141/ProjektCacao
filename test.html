<!DOCTYPE html>
<!-- saved from url=(0040)file:///C:/development/Projekt/test.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Network | Basic usage</title>
  <script type="text/javascript" src="./lib/js/jquery-3.2.0.min.js"></script>
  <script type="text/javascript" src="./lib/js/jquery.layout.js"></script>  
  <script type="text/javascript" src="./lib/js/vis.js"></script>    
  <script type="text/javascript" src="./lib/js/jquery-ui.min.js"></script>
  <link rel="stylesheet" type="text/css" href="./lib/css/vis.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/layout-default-latest.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.structure.min.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.theme.min.css">    

  <style type="text/css">
    #cfgNetwork {
      width: 1920px;
      height: 1024px;
      border: 1px solid lightgray;
    }
	#signature {
		font-size: x-large;
		font-weight: bold;
	}
	.pass-button {
		width: 190px;
		font-size: small;
	}
	.pass-button:focus {
		background-color: #A6A6A6;
	}
	.pass-button-active {
		background-color: #A6A6A6;
	}
	#cfgStatistics {
		float: right;
	}
  </style>
</head>
<body>

<div class="ui-layout-center">
	Search: <input id="cfgSearch"> 
	<label for="cfgShowBB">show BB
		<input type="checkbox" id="cfgShowBB" name="checkbox-showBB" value="checkbox-showBB" onclick="showControlFlow(cfgSelectedPass);" checked />      
    </label>
	<div id="cfgStatistics"></div> 
	<div id="cfgNetwork">
		<div class="vis-network" tabindex="900" style="position: relative; overflow: hidden; touch-action: pan-y; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;">
			<canvas width="1920" height="1024" style="position: relative; touch-action: none; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;">
			</canvas>
		</div>
	</div>
</div>
<div class="ui-layout-north">
	<div id="signature"></div>
</div>
<div class="ui-layout-west">
	Passes:<div id="passList"></div>
</div>

<div class="ui-layout-south"></div>
<div class="ui-layout-east"></div>

</body>

<script type="text/javascript">

    /**
     * start chrome with '--allow-file-access-from-files' for loading external local files!
     */
	var uiLayoutDefaults = {
		initClosed: true,   
		size:	"auto",		
		north: {
			size: 		40,	
			resizable: 	true,
			slidable:	true,
			initClosed:	false
		},
		west: {
			size: 		220,	
			resizable: 	true,
			slidable:	true,
			initClosed:	false
		}
	};
	
	var uiLayout; 
	var jsonData = null;   
	$(document).ready(function () {
		$('body').layout(uiLayoutDefaults);
		loadLocalJSON(function(response) {
			jsonData= JSON.parse(response);
			//preventButtonDefault();
			initSignature();
			initPassList();
			showControlFlow(4);
		}, "./xyz.json");		
	});

    // helper method to load local JSON file
    function loadLocalJSON(callback, fileName) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', fileName, true);
        xobj.onreadystatechange = function() {
            if (xobj.readyState == 4) {
                callback(xobj.responseText);
            }
        }
        xobj.send(null);
    }
    
	function preventButtonDefault() {
		$( "button, input, a" ).click( function( event ) {
		  event.preventDefault();
		});
	}
	
	function initSignature() {	
		var	className = jsonData.class.replace(/\//g, '.');
		var methodSignature = jsonData.method + jsonData.desc;
		$('#signature').append(className + ": " + methodSignature);
	}
	
	function initPassList(passes) {		
		var passList = $('#passList');		
		for (var passIndex in jsonData.passes) {
			var pass = jsonData.passes[passIndex];
			var name = pass.name;			
			// strip the extra 'Pass' from the Name
			name = name.slice(0, name.lastIndexOf("Pass"));		
			passList.append("<button"
				+ " id=\"passButton" + passIndex + "\"" 
				+ " class=\"pass-button ui-button ui-widget ui-corner-all\"" 
				+ " onclick=\"showControlFlow(" + passIndex + ");\">" + name + "</button>"); 
		}
	}
	
	// returns the root element
	function findRoot(nodes) {
		for(var i=0;i<nodes.length;i++) {
			if(nodes[i].root) {
				return nodes[i];
			}
		}
		return null;
	}

	function findNodeById(nodes, id) {
		for (var i=0; i<nodes.length; i++) {
			if (nodes[i].id == id) {
				return nodes[i];
			}
		}
		return null;
	}

	function findEdges(node, edges) {
		return edges.filter(function (edge) { return edge.from == node.id});
	}

	var maxLevel = 0;
	function setHierarchy(nodeData, edgeData, node, level) {
		if (node.level != null) {
			return;
		}
		if (level > maxLevel) {
			maxLevel = level;
		}
		console.log("set node.level to " + level + " for id: " + node.id + " and type " + node.name);
		node.level = level;
		var cfgEdges = findEdges(node, edgeData).filter(isCfgEdge);
		for (var i=0; i < cfgEdges.length; i++) {
			var childNode = findNodeById(nodeData, cfgEdges[i].to);
			setHierarchy(nodeData, edgeData, childNode, level + 1);
		}
	}

	function isCfgNode(node) {
		return $.inArray(node.name, ["BeginInst", "GOTOInst", "RETURNInst", "IFInst"]) != -1;
	}

	function isCfgEdge(edge) {
		return $.inArray(edge.type, ["cfg", "bb"]) != -1;
	}
	
	function getCfgNodeDisplayString(node, omitId) {
		var outputValue = ""; 
		if (!omitId) {
			outputValue += "[" + node.id + "]: ";
		}
		outputValue += node.name;	
		
		if (node.operands) {
			outputValue += "[";
			// TODO comparator yet missing!
			if (node.name==="IFInst") {
				outputValue += "#" + node.operands[0] + " ? " + "#" + node.operands[1];
			} else {
				outputValue += node.operands.map(function (id) { return "#" + id }).toString();
			}
			outputValue += "]";
		}
		return outputValue;
	}
	
	var cfgRoot;
	var cfgNodeData;
	var cfgEdgeData;
	var cfgNodes;
	var cfgEdges;
	var cfgNodeMap;	
	var cfgData;
	var cfgOptions;
	var cfgNetwork;
	var cfgSelectedPass;
	
    function showControlFlow(passIndex) {	
				
		// mark the selected pass
		cfgSelectedPass = passIndex;
		$("#passList").children().removeClass("pass-button-active");
		$("#passButton" + passIndex).addClass("pass-button-active");
		
		cfgNodeMap = {};			
		$("#cfgStatistics").text("");
		
		// no HIR in this pass
		if (!jsonData.passes[passIndex].nodes || jsonData.passes[passIndex].nodes.length <= 0) {			
			cfgNodes.clear();
			cfgEdges.clear();					
			return;
		}	
		
		// print statistics
		var pass = jsonData.passes[passIndex];
		$("#cfgStatistics").html(
			"<b>" + pass.nodes.reduce(function(n, val) {return n + (val.name === "BeginInst");}, 0) + "</b>x BB, " + 
			"<b>" + pass.nodes.length + "</b>x instructions"
		);	
		
        // create an array with nodes
        cfgNodeData = pass.nodes.filter(isCfgNode);
        cfgEdgeData = pass.edges.filter(isCfgEdge);				
		
		// create a deep copy of nodes and edges
		cfgNodeData =  JSON.parse(JSON.stringify(cfgNodeData));
		cfgEdgeData =  JSON.parse(JSON.stringify(cfgEdgeData));
		
		// create map for accessing the nodes over their id
		$.each(cfgNodeData, function (index, node) {
			cfgNodeMap[node.id] = node;
			node.label = getCfgNodeDisplayString(node);		
			if (node.BB) {
				node.group = node.BB;
			}
		});

		// collapse BasicBlocks to a single block
		if ($('#cfgShowBB').prop('checked')) {
		
			// create a map for accessing edges by the key "edge.from"
			var cfgEdgeMap = {};
			$.each(cfgEdgeData, function (index, edge) {
				var list = cfgEdgeMap[edge.from];
				if (list === undefined) {
					list = [];
					cfgEdgeMap[edge.from] = list;
				}
				list.push(edge);
			});
				
			cfgNodeData = cfgNodeData.filter(function (node) { return node.name === "BeginInst";});
			$.each(cfgNodeData, function (index, beginInst) {
				// BeginInst and EndInst have a 1:1 relationship
				var bbEdge = cfgEdgeMap[beginInst.id][0];
				var endInst = cfgNodeMap[bbEdge.to];
				
				// adjust the label
				beginInst.label = "BB #" + beginInst.id + " => #" + endInst.id;
				if (endInst.name !== "GOTOInst") {
					beginInst.label += "\n" + getCfgNodeDisplayString(endInst, true);
				}
				
				// adjust outgoing edges to the combined begin block
				var edgeList = cfgEdgeMap[endInst.id];
				if (edgeList) {
					for (var edge of edgeList) {
						edge.from = beginInst.id;
					}
				}
			});
			
			cfgEdgeData = cfgEdgeData.filter(function (edge) { return edge.type !== 'bb';});				
		}

		// format edges
		$.each(cfgEdgeData, function (index, edge) {
			if (edge.type == 'bb') {
				edge.dashes = true;
			// set label true/false for if branches
			} else if (edge.type == 'cfg' && typeof edge.trueBranch != 'undefined') {
				edge.label = edge.trueBranch;
			}
		});

		cfgRoot = findRoot(cfgNodeData);
		setHierarchy(cfgNodeData, cfgEdgeData, cfgRoot, 0);
		// set all other levels to max + 1;
		cfgNodeData
			.filter(function (node) {return typeof node.level == 'undefined'})
			.forEach(function(node) {node.level = maxLevel + 1;});

		// TODO: evaluate => showing edge labels only on hover => https://jsfiddle.net/8xrcbg0k/2/
		// overlay request => https://github.com/almende/vis/issues/2139/
		// TODO: select groups of nodes with right mouse => https://github.com/almende/vis/issues/977
		// TODO: drawing on canvas => http://visjs.org/examples/network/events/renderEvents.html
		//       convex shape => http://jsfiddle.net/rLf78a6x/8/
		//       gray out non selected nodes / edges => http://jsfiddle.net/bokm6ymy/   

		if (!cfgNetwork) {
			// create a network		
		
			// filter nodes and edges for control flow
			cfgNodes = new vis.DataSet(cfgNodeData);
			cfgEdges = new vis.DataSet(cfgEdgeData);			
			cfgData = {
				nodes: cfgNodes,
				edges: cfgEdges,
			};		
			cfgOptions = {
				nodes: {
					shape: "box",
				},
				edges: {
					arrows: {
						to: {
							enabled: true
						}
					},
					smooth: {
						enabled: true,
						type: 'continuous'
					}
				},
				layout: {
					randomSeed: undefined,
					improvedLayout: true,
					hierarchical: {
						enabled: true,
						//levelSeparation: 100,
						nodeSpacing: 150,
						//treeSpacing: 100,
						blockShifting: true,
						edgeMinimization: true,
						parentCentralization: true,
						direction: 'UD',        // UD, DU, LR, RL
						sortMethod: 'directed'   // hubsize, directed
					}
				},
				physics: {
					enabled: false
				}
			}
		
			var cfgContainer = document.getElementById('cfgNetwork');
			cfgNetwork = new vis.Network(cfgContainer, cfgData, cfgOptions);		
			cfgNetwork.fit();
		} else {
			// network already has been drawn
			cfgEdges.clear();			
			cfgNodes.clear();			
			cfgEdges.add(cfgEdgeData);
			cfgNodes.add(cfgNodeData);			
		}		
		
		$( "#cfgSearch" ).autocomplete({
		  minLength: 0,
		  source: cfgNodeData,
		  focus: function( event, ui ) {
			$("#cfgSearch").val( ui.item.id );
			cfgNetwork.selectNodes([ui.item.id]);
			cfgNetwork.focus(ui.item.id);
			return false;
		  },
		  select: function( event, ui ) {
			$("#cfgSearch").val( ui.item.id );			 
			cfgNetwork.selectNodes([ui.item.id]);
			cfgNetwork.focus(ui.item.id, {scale: 1.2});						
			return false;
		  }
		})
		.autocomplete( "instance" )._renderItem = function( ul, node ) {
		  return $( "<li>" )
			.append( "<div>" + node.label + "</div>" )
			.appendTo( ul );
		};
		
		cfgNetwork.stabilize(5000);
	}
	

        // set the first initial zoom level
        /*network.once('initRedraw', function() {
            if (lastClusterZoomLevel === 0) {
                lastClusterZoomLevel = network.getScale();
            }
        });

        // cluster on zoom => http://visjs.org/examples/network/other/clusteringByZoom.html
        var clusterIndex = 0;
        var clusters = [];
        var lastClusterZoomLevel = 0;
        var clusterFactor = 0.5;

        // we use the zoom event for our clustering
        network.on('zoom', function (params) {
            if (params.direction == '-') {
                if (params.scale < lastClusterZoomLevel*clusterFactor) {
                    makeClusters(params.scale);
                    lastClusterZoomLevel = params.scale;
                }
            }
            else {
                openClusters(params.scale);
            }
        });

        // cluster by basic blocks
        // if we click on a node, we want to open it up!
        network.on("selectNode", function (params) {
            if (params.nodes.length == 1) {
                if (network.isCluster(params.nodes[0]) == true) {
                    network.openCluster(params.nodes[0])
                }
            }
        });

        // make the clusters
        function makeClusters(scale) {
            var clusterOptionsByData = {
                processProperties: function (clusterOptions, childNodes) {
                    clusterIndex = clusterIndex + 1;
                    var childrenCount = 0;
                    for (var i = 0; i < childNodes.length; i++) {
                        childrenCount += childNodes[i].childrenCount || 1;
                    }
                    clusterOptions.childrenCount = childrenCount;
                    clusterOptions.label = "# " + childrenCount + "";
                    clusterOptions.font = {size: childrenCount*5+30}
                    clusterOptions.id = 'cluster:' + clusterIndex;
                    clusters.push({id:'cluster:' + clusterIndex, scale:scale});
                    return clusterOptions;
                },
                clusterNodeProperties: {borderWidth: 3, shape: 'database', font: {size: 30}}
            }
            network.clusterOutliers(clusterOptionsByData);
            if (document.getElementById('stabilizeCheckbox').checked === true) {
                // since we use the scale as a unique identifier, we do NOT want to fit after the stabilization
                network.setOptions({physics:{stabilization:{fit: false}}});
                network.stabilize();
            }
        }

        // open them back up!
        function openClusters(scale) {
            var newClusters = [];
            var declustered = false;
            for (var i = 0; i < clusters.length; i++) {
                if (clusters[i].scale < scale) {
                    network.openCluster(clusters[i].id);
                    lastClusterZoomLevel = scale;
                    declustered = true;
                }
                else {
                    newClusters.push(clusters[i])
                }
            }
            clusters = newClusters;
            if (declustered === true && document.getElementById('stabilizeCheckbox').checked === true) {
                // since we use the scale as a unique identifier, we do NOT want to fit after the stabilization
                network.setOptions({physics:{stabilization:{fit: false}}});
                network.stabilize();
            }
        }*/
    
</script>

</html>