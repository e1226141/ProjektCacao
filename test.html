<!DOCTYPE html>
<!-- saved from url=(0040)file:///C:/development/Projekt/test.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Network | Basic usage</title>
  <script type="text/javascript" src="./lib/js/jquery-3.2.0.min.js"></script>
  <script type="text/javascript" src="./lib/js/jquery.layout.js"></script>  
  <script type="text/javascript" src="./lib/js/vis.js"></script>    
  <script type="text/javascript" src="./lib/js/jquery-ui.min.css"></script>
  <link rel="stylesheet" type="text/css" href="./lib/css/vis.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/layout-default-latest.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.structure.min.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.theme.min.css">    

  <style type="text/css">
    #mynetwork {
      width: 1920px;
      height: 1024px;
      border: 1px solid lightgray;
    }
	.signature {
		font-size: x-large;
		font-weight: bold;
	}
	.pass-button {
		width: 190px;
		font-size: small;
	}
	.pass-button:focus {
		background-color: #A6A6A6;
	}
	.pass-button-active {
		background-color: #A6A6A6;
	}
  </style>
</head>
<body>

<div class="ui-layout-center">
	<div id="mynetwork">
		<div class="vis-network" tabindex="900" style="position: relative; overflow: hidden; touch-action: pan-y; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;">
			<canvas width="1920" height="1024" style="position: relative; touch-action: none; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;">
			</canvas>
		</div>
	</div>
</div>
<div class="ui-layout-north">
	<div id="signature"></div>
</div>
<div class="ui-layout-west">
	Passes:<div id="passList"></div>
</div>

<div class="ui-layout-south"></div>
<div class="ui-layout-east"></div>

</body>

<script type="text/javascript">

    /**
     * start chrome with '--allow-file-access-from-files' for loading external local files!
     */
	var uiLayoutDefaults = {
		initClosed: true,   
		size:	"auto",		
		north: {
			size: 		40,	
			resizable: 	true,
			slidable:	true,
			initClosed:	false
		},
		west: {
			size: 		220,	
			resizable: 	true,
			slidable:	true,
			initClosed:	false
		}
	};
	
	var uiLayout; 
	$(document).ready(function () {
		$('body').layout(uiLayoutDefaults);
	});

    // helper method to load local JSON file
    function loadLocalJSON(callback, fileName) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', fileName, true);
        xobj.onreadystatechange = function() {
            if (xobj.readyState == 4) {
                callback(xobj.responseText);
            }
        }
        xobj.send(null);
    }

    var jsonData = null;
    loadLocalJSON(function(response) {
        jsonData= JSON.parse(response);
		preventButtonDefault();
		initSignature();
		initPassList();
        showControlFlow(4);
    }, "./xyz.json");

	function preventButtonDefault() {
		$( "button, input, a" ).click( function( event ) {
		  event.preventDefault();
		});
	}
	
	function initSignature() {	
		var	className = jsonData.class.replace(/\//g, '.');
		var methodSignature = jsonData.method + jsonData.desc;
		$('#signature').append(className + ": " + methodSignature);
	}
	
	function initPassList(passes) {		
		var passList = $('#passList');		
		for (var passIndex in jsonData.passes) {
			var pass = jsonData.passes[passIndex];
			var name = pass.name;			
			// strip the extra 'Pass' from the Name
			name = name.slice(0, name.lastIndexOf("Pass"));		
			passList.append("<button"
				+ " id=\"passButton" + passIndex + "\"" 
				+ " class=\"pass-button ui-button ui-widget ui-corner-all\"" 
				+ " onclick=\"showControlFlow(" + passIndex + ");\">" + name + "</button>"); 
		}
	}
	
	// returns the root element
	function findRoot(nodes) {
		for(var i=0;i<nodes.length;i++) {
			if(nodes[i].root) {
				return nodes[i];
			}
		}
		return null;
	}

	function findNodeById(nodes, id) {
		for (var i=0; i<nodes.length; i++) {
			if (nodes[i].id == id) {
				return nodes[i];
			}
		}
		return null;
	}

	function findEdges(node, edges) {
		return edges.filter(function (edge) { return edge.from == node.id});
	}

	var maxLevel = 0;
	function setHierarchy(node, level) {
		if (node.level != null) {
			return;
		}
		if (level > maxLevel) {
			maxLevel = level;
		}
		console.log("set node.level to " + level + " for id: " + node.id + " and type " + node.name);
		node.level = level;
		var cfgEdges = findEdges(node, edgeData).filter(isCfgEdge);
		for (var i=0; i<cfgEdges.length; i++) {
			var childNode = findNodeById(nodeData, cfgEdges[i].to);
			setHierarchy(childNode, level + 1);
		}
	}

	function isCfgNode(node) {
		return $.inArray(node.name, ["BeginInst", "GOTOInst", "RETURNInst", "IFInst"]) != -1;
	}

	function isCfgEdge(edge) {
		return $.inArray(edge.type, ["cfg", "bb"]) != -1;
	}
	
	var root;
	var nodeData;
	var edgeData;
	var nodes;
	var edges;
	var container;
	var data;
	var options;
	var network;
	
    function showControlFlow(passIndex) {
		
		// mark the selected pass
		$("#passList").children().removeClass("pass-button-active");
		$("#passButton" + passIndex).addClass("pass-button-active");
		
        // create an array with nodes
        nodeData = jsonData.passes[passIndex].nodes;
        edgeData = jsonData.passes[passIndex].edges;
		
		if (nodeData.length <= 0) {
			nodes.clear();
			edges.clear();		
			return;
		}

		// create labels
		$.each(nodeData, function (index, node) {
			node.label = "[" + node.id + "]: " + node.name;
			if (node.BB) {
				node.group = node.BB;
			}
		});

		// format edges
		$.each(edgeData, function (index, edge) {
			if (edge.type == 'bb') {
				edge.dashes = true;
			// set label true/false for if branches
			} else if (edge.type == 'cfg' && typeof edge.trueBranch != 'undefined') {
				edge.label = edge.trueBranch;
			}
		});

		root = findRoot(nodeData);
		setHierarchy(root, 0);
		// set all other levels to max + 1;
		nodeData
			.filter(function (node) {return typeof node.level == 'undefined'})
			.forEach(function(node) {node.level = maxLevel + 1;});
		// filter nodes and edges for control flow
		nodes = new vis.DataSet(nodeData.filter(isCfgNode));
		edges = new vis.DataSet(edgeData.filter(isCfgEdge));

		// TODO: evaluate => showing edge labels only on hover => https://jsfiddle.net/8xrcbg0k/2/
		// overlay request => https://github.com/almende/vis/issues/2139/
		// TODO: select groups of nodes with right mouse => https://github.com/almende/vis/issues/977
		// TODO: drawing on canvas => http://visjs.org/examples/network/events/renderEvents.html
		//       convex shape => http://jsfiddle.net/rLf78a6x/8/
		//       gray out non selected nodes / edges => http://jsfiddle.net/bokm6ymy/   

		// create a network
		container = document.getElementById('mynetwork');
		data = {
			nodes: nodes,
			edges: edges,
		};
		options = {
			nodes: {
				shape: "box",
			},
			edges: {
				arrows: {
					to: {
						enabled: true
					}
				},
				smooth: {
					enabled: true,
					type: 'continuous'
				}
			},
			layout: {
				randomSeed: undefined,
				improvedLayout: true,
				hierarchical: {
					enabled: true,
					levelSeparation: 100,
					nodeSpacing: 450,
					treeSpacing: 100,
					blockShifting: true,
					edgeMinimization: true,
					parentCentralization: true,
					direction: 'UD',        // UD, DU, LR, RL
					sortMethod: 'directed'   // hubsize, directed
				}
			},
			physics: {
				enabled: false
			}
		}
		network = new vis.Network(container, data, options);		
	}

        // set the first initial zoom level
        /*network.once('initRedraw', function() {
            if (lastClusterZoomLevel === 0) {
                lastClusterZoomLevel = network.getScale();
            }
        });

        // cluster on zoom => http://visjs.org/examples/network/other/clusteringByZoom.html
        var clusterIndex = 0;
        var clusters = [];
        var lastClusterZoomLevel = 0;
        var clusterFactor = 0.5;

        // we use the zoom event for our clustering
        network.on('zoom', function (params) {
            if (params.direction == '-') {
                if (params.scale < lastClusterZoomLevel*clusterFactor) {
                    makeClusters(params.scale);
                    lastClusterZoomLevel = params.scale;
                }
            }
            else {
                openClusters(params.scale);
            }
        });

        // cluster by basic blocks
        // if we click on a node, we want to open it up!
        network.on("selectNode", function (params) {
            if (params.nodes.length == 1) {
                if (network.isCluster(params.nodes[0]) == true) {
                    network.openCluster(params.nodes[0])
                }
            }
        });

        // make the clusters
        function makeClusters(scale) {
            var clusterOptionsByData = {
                processProperties: function (clusterOptions, childNodes) {
                    clusterIndex = clusterIndex + 1;
                    var childrenCount = 0;
                    for (var i = 0; i < childNodes.length; i++) {
                        childrenCount += childNodes[i].childrenCount || 1;
                    }
                    clusterOptions.childrenCount = childrenCount;
                    clusterOptions.label = "# " + childrenCount + "";
                    clusterOptions.font = {size: childrenCount*5+30}
                    clusterOptions.id = 'cluster:' + clusterIndex;
                    clusters.push({id:'cluster:' + clusterIndex, scale:scale});
                    return clusterOptions;
                },
                clusterNodeProperties: {borderWidth: 3, shape: 'database', font: {size: 30}}
            }
            network.clusterOutliers(clusterOptionsByData);
            if (document.getElementById('stabilizeCheckbox').checked === true) {
                // since we use the scale as a unique identifier, we do NOT want to fit after the stabilization
                network.setOptions({physics:{stabilization:{fit: false}}});
                network.stabilize();
            }
        }

        // open them back up!
        function openClusters(scale) {
            var newClusters = [];
            var declustered = false;
            for (var i = 0; i < clusters.length; i++) {
                if (clusters[i].scale < scale) {
                    network.openCluster(clusters[i].id);
                    lastClusterZoomLevel = scale;
                    declustered = true;
                }
                else {
                    newClusters.push(clusters[i])
                }
            }
            clusters = newClusters;
            if (declustered === true && document.getElementById('stabilizeCheckbox').checked === true) {
                // since we use the scale as a unique identifier, we do NOT want to fit after the stabilization
                network.setOptions({physics:{stabilization:{fit: false}}});
                network.stabilize();
            }
        }*/
    
</script>

</html>