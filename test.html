<!DOCTYPE html>
<!-- saved from url=(0040)file:///C:/development/Projekt/test.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Network | Basic usage</title>
  <script type="text/javascript" src="./lib/js/jquery-3.2.0.min.js"></script>
  <script type="text/javascript" src="./lib/js/jquery.layout.js"></script>  
  <script type="text/javascript" src="./lib/js/vis.js"></script>    
  <script type="text/javascript" src="./lib/js/jquery-ui.min.css"></script>
  <link rel="stylesheet" type="text/css" href="./lib/css/vis.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/layout-default-latest.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.structure.min.css">
  <link rel="stylesheet" type="text/css" href="./lib/css/jquery-ui.theme.min.css">    

  <style type="text/css">
    #mynetwork {
      width: 1920px;
      height: 1024px;
      border: 1px solid lightgray;
    }
	#signature {
		font-size: x-large;
		font-weight: bold;
	}
	.pass-button {
		width: 190px;
		font-size: small;
	}
	.pass-button:focus {
		background-color: #A6A6A6;
	}
	.pass-button-active {
		background-color: #A6A6A6;
	}
  </style>
</head>
<body>

<div class="ui-layout-center">
	<div id="mynetwork">
		<div class="vis-network" tabindex="900" style="position: relative; overflow: hidden; touch-action: pan-y; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;">
			<canvas width="1920" height="1024" style="position: relative; touch-action: none; user-select: none; -webkit-user-drag: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); width: 100%; height: 100%;">
			</canvas>
		</div>
	</div>
</div>
<div class="ui-layout-north">
	<div id="signature"></div>
</div>
<div class="ui-layout-west">
	Passes:<div id="passList"></div>
</div>

<div class="ui-layout-south"></div>
<div class="ui-layout-east"></div>

</body>

<script type="text/javascript">

    /**
     * start chrome with '--allow-file-access-from-files' for loading external local files!
     */
	var uiLayoutDefaults = {
		initClosed: true,   
		size:	"auto",		
		north: {
			size: 		40,	
			resizable: 	true,
			slidable:	true,
			initClosed:	false
		},
		west: {
			size: 		220,	
			resizable: 	true,
			slidable:	true,
			initClosed:	false
		}
	};
	
	var uiLayout; 
	$(document).ready(function () {
		$('body').layout(uiLayoutDefaults);
	});

    // helper method to load local JSON file
    function loadLocalJSON(callback, fileName) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', fileName, true);
        xobj.onreadystatechange = function() {
            if (xobj.readyState == 4) {
                callback(xobj.responseText);
            }
        }
        xobj.send(null);
    }

    var jsonData = null;
    loadLocalJSON(function(response) {
        jsonData= JSON.parse(response);
		preventButtonDefault();
		initSignature();
		initPassList();
        showControlFlow(4);
    }, "./xyz.json");

	function preventButtonDefault() {
		$( "button, input, a" ).click( function( event ) {
		  event.preventDefault();
		});
	}
	
	function initSignature() {	
		var	className = jsonData.class.replace(/\//g, '.');
		var methodSignature = jsonData.method + jsonData.desc;
		$('#signature').append(className + ": " + methodSignature);
	}
	
	function initPassList(passes) {		
		var passList = $('#passList');		
		for (var passIndex in jsonData.passes) {
			var pass = jsonData.passes[passIndex];
			var name = pass.name;			
			// strip the extra 'Pass' from the Name
			name = name.slice(0, name.lastIndexOf("Pass"));		
			passList.append("<button"
				+ " id=\"passButton" + passIndex + "\"" 
				+ " class=\"pass-button ui-button ui-widget ui-corner-all\"" 
				+ " onclick=\"showControlFlow(" + passIndex + ");\">" + name + "</button>"); 
		}
	}
	
	// returns the root element
	function findRoot(nodes) {
		for(var i=0;i<nodes.length;i++) {
			if(nodes[i].root) {
				return nodes[i];
			}
		}
		return null;
	}

	function findNodeById(nodes, id) {
		for (var i=0; i<nodes.length; i++) {
			if (nodes[i].id == id) {
				return nodes[i];
			}
		}
		return null;
	}

	function findEdges(node, edges) {
		return edges.filter(function (edge) { return edge.from == node.id});
	}

	var maxLevel = 0;
	function setHierarchy(nodeData, edgeData, node, level) {
		if (node.level != null) {
			return;
		}
		if (level > maxLevel) {
			maxLevel = level;
		}
		console.log("set node.level to " + level + " for id: " + node.id + " and type " + node.name);
		node.level = level;
		var cfgEdges = findEdges(node, edgeData).filter(isCfgEdge);
		for (var i=0; i < cfgEdges.length; i++) {
			var childNode = findNodeById(nodeData, cfgEdges[i].to);
			setHierarchy(nodeData, edgeData, childNode, level + 1);
		}
	}

	function isCfgNode(node) {
		return $.inArray(node.name, ["BeginInst", "GOTOInst", "RETURNInst", "IFInst"]) != -1;
	}

	function isCfgEdge(edge) {
		return $.inArray(edge.type, ["cfg", "bb"]) != -1;
	}
	
	function getCfgNodeDisplayString(node, omitId) {
		var outputValue = ""; 
		if (!omitId) {
			outputValue += "[" + node.id + "]: ";
		}
		outputValue += node.name;	
		
		if (node.operands) {
			outputValue += "[";
			// TODO comparator yet missing!
			if (node.name==="IFInst") {
				outputValue += "#" + node.operands[0] + " ? " + "#" + node.operands[1];
			} else {
				outputValue += node.operands.map(function (id) { return "#" + id }).toString();
			}
			outputValue += "]";
		}
		return outputValue;
	}
	
	var cfgRoot;
	var cfgNodeData;
	var cfgEdgeData;
	var cfgNodes;
	var cfgEdges;
	var cfgNodeMap;
	var cfgContainer;
	var cfgData;
	var cfgOptions;
	var cfgNetwork;
	var cfgSimplifyStructure = true;
	
    function showControlFlow(passIndex) {
		
		// mark the selected pass
		$("#passList").children().removeClass("pass-button-active");
		$("#passButton" + passIndex).addClass("pass-button-active");
		
		cfgNodeMap = {};
		
		// no HIR
		if (!jsonData.passes[passIndex].nodes || jsonData.passes[passIndex].nodes.length <= 0) {
			cfgNodes.clear();
			cfgEdges.clear();					
			return;
		}	
		
        // create an array with nodes
        cfgNodeData = jsonData.passes[passIndex].nodes.filter(isCfgNode);
        cfgEdgeData = jsonData.passes[passIndex].edges.filter(isCfgEdge);				
		
		// create map for accessing the nodes over their id
		$.each(cfgNodeData, function (index, node) {
			cfgNodeMap[node.id] = node;
			node.label = getCfgNodeDisplayString(node);		
			if (node.BB) {
				node.group = node.BB;
			}
		});

		// collapse BasicBlocks to a single block
		if (cfgSimplifyStructure) {
		
			// create a map for accessing edges by the key "edge.from"
			var cfgEdgeMap = {};
			$.each(cfgEdgeData, function (index, edge) {
				var list = cfgEdgeMap[edge.from];
				if (list === undefined) {
					list = [];
					cfgEdgeMap[edge.from] = list;
				}
				list.push(edge);
			});
				
			cfgNodeData = cfgNodeData.filter(function (node) { return node.name === "BeginInst";});
			$.each(cfgNodeData, function (index, beginInst) {
				// BeginInst and EndInst have a 1:1 relationship
				var bbEdge = cfgEdgeMap[beginInst.id][0];
				var endInst = cfgNodeMap[bbEdge.to];
				
				// adjust the label
				beginInst.label = "BB #" + beginInst.id;
				if (endInst.name !== "GOTOInst") {
					beginInst.label += "\n" + getCfgNodeDisplayString(endInst, true);
				}
				
				// adjust outgoing edges to the combined begin block
				var edgeList = cfgEdgeMap[endInst.id];
				if (edgeList) {
					for (var edge of edgeList) {
						edge.from = beginInst.id;
					}
				}
			});
			
			cfgEdgeData = jsonData.passes[passIndex].edges.filter(function (edge) { return edge.type !== 'bb';});				
		}

		// format edges
		$.each(cfgEdgeData, function (index, edge) {
			if (edge.type == 'bb') {
				edge.dashes = true;
			// set label true/false for if branches
			} else if (edge.type == 'cfg' && typeof edge.trueBranch != 'undefined') {
				edge.label = edge.trueBranch;
			}
		});

		cfgRoot = findRoot(cfgNodeData);
		setHierarchy(cfgNodeData, cfgEdgeData, cfgRoot, 0);
		// set all other levels to max + 1;
		cfgNodeData
			.filter(function (node) {return typeof node.level == 'undefined'})
			.forEach(function(node) {node.level = maxLevel + 1;});
		// filter nodes and edges for control flow
		cfgNodes = new vis.DataSet(cfgNodeData);
		cfgEdges = new vis.DataSet(cfgEdgeData);

		// TODO: evaluate => showing edge labels only on hover => https://jsfiddle.net/8xrcbg0k/2/
		// overlay request => https://github.com/almende/vis/issues/2139/
		// TODO: select groups of nodes with right mouse => https://github.com/almende/vis/issues/977
		// TODO: drawing on canvas => http://visjs.org/examples/network/events/renderEvents.html
		//       convex shape => http://jsfiddle.net/rLf78a6x/8/
		//       gray out non selected nodes / edges => http://jsfiddle.net/bokm6ymy/   

		// create a network
		cfgContainer = document.getElementById('mynetwork');
		cfgData = {
			nodes: cfgNodes,
			edges: cfgEdges,
		};
		cfgOptions = {
			nodes: {
				shape: "box",
			},
			edges: {
				arrows: {
					to: {
						enabled: true
					}
				},
				smooth: {
					enabled: true,
					type: 'continuous'
				}
			},
			layout: {
				randomSeed: undefined,
				improvedLayout: true,
				hierarchical: {
					enabled: true,
					//levelSeparation: 100,
					nodeSpacing: 150,
					//treeSpacing: 100,
					blockShifting: true,
					edgeMinimization: true,
					parentCentralization: true,
					direction: 'UD',        // UD, DU, LR, RL
					sortMethod: 'directed'   // hubsize, directed
				}
			},
			physics: {
				enabled: false
			}
		}
		cfgNetwork = new vis.Network(cfgContainer, cfgData, cfgOptions);		
		cfgNetwork.stabilize(5000);
	}

        // set the first initial zoom level
        /*network.once('initRedraw', function() {
            if (lastClusterZoomLevel === 0) {
                lastClusterZoomLevel = network.getScale();
            }
        });

        // cluster on zoom => http://visjs.org/examples/network/other/clusteringByZoom.html
        var clusterIndex = 0;
        var clusters = [];
        var lastClusterZoomLevel = 0;
        var clusterFactor = 0.5;

        // we use the zoom event for our clustering
        network.on('zoom', function (params) {
            if (params.direction == '-') {
                if (params.scale < lastClusterZoomLevel*clusterFactor) {
                    makeClusters(params.scale);
                    lastClusterZoomLevel = params.scale;
                }
            }
            else {
                openClusters(params.scale);
            }
        });

        // cluster by basic blocks
        // if we click on a node, we want to open it up!
        network.on("selectNode", function (params) {
            if (params.nodes.length == 1) {
                if (network.isCluster(params.nodes[0]) == true) {
                    network.openCluster(params.nodes[0])
                }
            }
        });

        // make the clusters
        function makeClusters(scale) {
            var clusterOptionsByData = {
                processProperties: function (clusterOptions, childNodes) {
                    clusterIndex = clusterIndex + 1;
                    var childrenCount = 0;
                    for (var i = 0; i < childNodes.length; i++) {
                        childrenCount += childNodes[i].childrenCount || 1;
                    }
                    clusterOptions.childrenCount = childrenCount;
                    clusterOptions.label = "# " + childrenCount + "";
                    clusterOptions.font = {size: childrenCount*5+30}
                    clusterOptions.id = 'cluster:' + clusterIndex;
                    clusters.push({id:'cluster:' + clusterIndex, scale:scale});
                    return clusterOptions;
                },
                clusterNodeProperties: {borderWidth: 3, shape: 'database', font: {size: 30}}
            }
            network.clusterOutliers(clusterOptionsByData);
            if (document.getElementById('stabilizeCheckbox').checked === true) {
                // since we use the scale as a unique identifier, we do NOT want to fit after the stabilization
                network.setOptions({physics:{stabilization:{fit: false}}});
                network.stabilize();
            }
        }

        // open them back up!
        function openClusters(scale) {
            var newClusters = [];
            var declustered = false;
            for (var i = 0; i < clusters.length; i++) {
                if (clusters[i].scale < scale) {
                    network.openCluster(clusters[i].id);
                    lastClusterZoomLevel = scale;
                    declustered = true;
                }
                else {
                    newClusters.push(clusters[i])
                }
            }
            clusters = newClusters;
            if (declustered === true && document.getElementById('stabilizeCheckbox').checked === true) {
                // since we use the scale as a unique identifier, we do NOT want to fit after the stabilization
                network.setOptions({physics:{stabilization:{fit: false}}});
                network.stabilize();
            }
        }*/
    
</script>

</html>